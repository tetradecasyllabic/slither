<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slither AI Arena</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
        }
        #gameCanvas {
            background-color: #161b22; /* Slightly lighter inner background */
            border: 4px solid #30363d;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 4px, 6px, 0.2);
            touch-action: none; /* Prevent scroll on touch devices */
            cursor: crosshair;
        }
        .leaderboard-item {
            transition: all 0.3s ease;
        }
        .player-snake {
            background-color: rgba(59, 130, 246, 0.2) !important; /* Blue for the player */
            font-weight: bold;
            border-left: 3px solid #3b82f6;
        }

        /* Killer flash effect */
        @keyframes flashRed {
            0%, 100% { background-color: transparent; border-left-color: transparent; }
            50% { background-color: rgba(239, 68, 68, 0.4); border-left-color: #ef4444; }
        }
        .killer-flash {
            animation: flashRed 0.2s ease-in-out 5; 
        }
    </style>
</head>
<body>

<div class="min-h-screen p-4 flex flex-col items-center">
    <h1 class="text-3xl font-bold text-white mb-6 mt-4">üêç Slither AI Arena (Predator Mode)</h1>

    <!-- Canvas Wrapper for Overlay Positioning -->
    <div id="canvas-wrapper" class="relative w-full max-w-4xl flex justify-center items-center">
        <!-- Game Canvas Area -->
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <!-- Leaderboard Overlay -->
        <div id="leaderboard-overlay" class="absolute top-4 right-4 z-10 w-48 bg-gray-900/80 backdrop-blur-sm p-3 rounded-lg border border-gray-700 shadow-xl">
            <h2 class="text-lg font-bold text-gray-200 mb-2 border-b border-gray-700 pb-1">Leaderboard</h2>
            <div id="leaderboard" class="space-y-1 text-xs">
                <!-- Leaderboard items injected here -->
            </div>
            <div class="mt-3 pt-2 border-t border-gray-700">
                <p class="text-sm font-semibold text-gray-400">Your Score:</p>
                <p id="player-score" class="text-2xl font-extrabold text-green-400">0</p>
            </div>

            <!-- KILL LOG CONTAINER -->
            <div class="mt-4 pt-2 border-t border-gray-700">
                <h3 class="text-sm font-semibold text-red-400 mb-1">Kill Feed</h3>
                <div id="kill-log" class="space-y-1 h-20 overflow-hidden">
                    <!-- Kill messages will appear here -->
                </div>
            </div>
        </div>

        <!-- Status Message Overlay (Centered) -->
        <div id="status-message" class="absolute inset-0 flex items-center justify-center pointer-events-none hidden">
            <div id="status-text" class="p-4 bg-red-800/80 text-red-300 rounded-lg text-2xl font-extrabold shadow-2xl animate-pulse">
                You crashed! Respawning...
            </div>
        </div>
    </div>

    <!-- Minimal Info Footer -->
    <div id="info-footer" class="text-sm text-gray-400 mt-4 p-3 bg-[#161b22] rounded-xl border border-gray-700">
        <p>Controls: **Mouse/Touch** to steer | World Size: 4000 x 4000</p>
    </div>
</div>

<script>
// --- Configuration and Constants ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const VIEW_SIZE = { width: 800, height: 600 };
const WORLD_SIZE = 4000; 
const MAX_FOOD = 400;    
const MAX_AI_SNAKES = 30; 
const SNAKE_RADIUS = 5;
const FOOD_RADIUS = 2;
const INITIAL_SPEED = 1.8; 
const TURN_RATE = 0.06; 
const MIN_BODY_DISTANCE = SNAKE_RADIUS * 1.5; 

// AI Tuned Parameters
const LOOK_AHEAD_DISTANCE = 300; // Increased for more proactive avoidance
const COLLISION_DANGER_RADIUS = SNAKE_RADIUS * 3.5; 
const EDGE_AVOIDANCE_MARGIN = 150; 
const FOOD_SEARCH_RADIUS_SQ = 700 * 700; 
const HUNT_RADIUS_SQ = 1000 * 1000; // AI will hunt the leader if within this square distance
const PREDATOR_PREDICTION_DISTANCE = 150; // How far ahead AI predicts the leader's movement to cut them off
const GIVE_UP_TIME_FRAMES = 150; // 2.5 seconds at 60 FPS

// Maximum angular difference allowed for a food target (135 degrees)
const MAX_FOOD_ANGLE_DIFF = Math.PI * 0.75; 

// Leader Indicator Parameters
const ARROW_MARGIN = 30; 
const ARROW_SIZE = 10;   

// Kill Log Configuration
const MAX_KILL_LOG = 5;
let killLog = []; 

let gameRunning = false;
let cameraX = 0;
let cameraY = 0;
let food = []; 
let leaderSnake = null; 

// Explicitly declare global game state variables
let playerSnake;
let snakes = [];
let animationFrameId = null; 
let lastTime = 0; 

// Snake Class
class Snake {
    constructor(id, name, color, isPlayer = false) {
        this.id = id;
        this.name = name;
        this.color = color;
        
        this.isPlayer = isPlayer;
        if (this.isPlayer) this.color = '#3b82f6'; 

        this.isDeadAndAwaitingReset = false; 
        this.reset();
    }

    reset() {
        this.body = []; 
        this.angle = Math.random() * Math.PI * 2; 
        this.targetAngle = this.angle; 
        this.speed = INITIAL_SPEED;
        this.score = 0;
        this.isAlive = true;
        this.isRespawning = false; 
        this.isKiller = false; 
        
        // +1 for clockwise (right), -1 for counter-clockwise (left), 0 for no avoidance in progress
        this.avoidanceDirection = 0; 
        this.tempWanderTimer = 0; // New: Timer to force non-hunting/pure avoidance behavior

        // --- STARTING POSITION LOGIC ---
        const padding = 100; 
        const range = WORLD_SIZE - 2 * padding;
        const startX = padding + Math.random() * range;
        const startY = padding + Math.random() * range;

        const INITIAL_LENGTH = 15; 
        this.body.push({ x: startX, y: startY });
        for (let i = 1; i < INITIAL_LENGTH; i++) {
            this.body.push({
                x: startX - Math.cos(this.angle) * i * MIN_BODY_DISTANCE,
                y: startY - Math.sin(this.angle) * i * MIN_BODY_DISTANCE
            });
        }
    }

    // Adjust angle towards the target angle smoothly
    steer() {
        if (!this.isAlive) return;

        let diff = this.targetAngle - this.angle;

        // Normalize difference to be between -PI and PI
        if (diff > Math.PI) diff -= 2 * Math.PI;
        if (diff < -Math.PI) diff += 2 * Math.PI;

        if (Math.abs(diff) > TURN_RATE) {
            this.angle += Math.sign(diff) * TURN_RATE;
        } else {
            this.angle = this.targetAngle;
        }

        // Keep angle within 0 to 2*PI
        if (this.angle < 0) this.angle += 2 * Math.PI;
        if (this.angle >= 2 * Math.PI) this.angle -= 2 * Math.PI;
    }

    move() {
        if (!this.isAlive) return;

        this.steer();

        const head = this.body[0];

        // Calculate new head position based on angle and speed
        const newX = head.x + Math.cos(this.angle) * this.speed;
        const newY = head.y + Math.sin(this.angle) * this.speed;

        // Add new head
        this.body.unshift({ x: newX, y: newY });

        // Update score based on length (minus one for the head)
        this.score = this.body.length - 1;

        // Remove the tail only if we didn't grow
        if (!this.growing) {
            this.body.pop();
        }
        this.growing = false; // Reset growing flag
    }

    // Function called when food is eaten
    grow() {
        this.growing = true;
    }

    // Set target angle for player control
    setTargetAngle(newAngle) {
        this.targetAngle = newAngle;
    }
}

// Food Class (unchanged)
class Food {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

// --- Utilities ---
const CONSONANTS = 'bdfghjklmnprstvwxz';
const VOWELS = 'aeiou';

function generateRandomCVCVName() {
    const length = Math.floor(Math.random() * 8) + 3;
    let name = '';
    for (let i = 0; i < length; i++) {
        if (i % 2 === 0) { name += CONSONANTS.charAt(Math.floor(Math.random() * CONSONANTS.length)); }
        else { name += VOWELS.charAt(Math.floor(Math.random() * VOWELS.length)); }
    }
    return name.charAt(0).toUpperCase() + name.slice(1);
}

function getRandomColor() {
    const colors = [
        '#ef4444', '#f97316', '#84cc16', '#10b981',
        '#06b6d4', '#6366f1', '#ec4899', '#facc15',
    ];
    return colors[Math.floor(Math.random() * colors.length)];
}

function getRandomWorldPos() {
    const x = Math.random() * WORLD_SIZE;
    const y = Math.random() * WORLD_SIZE;
    return { x, y };
}

// --- Initialization & Spawning (unchanged) ---
function initGame() {
    canvas.width = VIEW_SIZE.width;
    canvas.height = VIEW_SIZE.height;

    snakes = [];
    food = [];
    killLog = []; 

    // 1. Create Player Snake
    playerSnake = new Snake(0, 'You', '#3b82f6', true); 
    snakes.push(playerSnake);

    // 2. Create AI Snakes 
    for (let i = 1; i <= MAX_AI_SNAKES; i++) {
        const aiName = generateRandomCVCVName();
        const aiColor = getRandomColor();
        snakes.push(new Snake(i, aiName, aiColor, false));
    }

    // 3. Create initial food 
    spawnFood();

    // 4. Start the game loop
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    lastTime = performance.now(); 
    animationFrameId = requestAnimationFrame(gameLoop); 
    gameRunning = true;
    document.getElementById('status-message').classList.add('hidden');
    document.getElementById('player-score').textContent = playerSnake.score;
    canvas.onclick = null;
    canvas.ontouchstart = null;
    updateKillLog(); 
}

function spawnFood() {
    while (food.length < MAX_FOOD) {
        food.push(new Food(getRandomWorldPos().x, getRandomWorldPos().y));
    }
}


// --- Drawing (Leader Indicator and general drawing) ---
function draw() {
    // 1. Calculate Camera Offset
    if (playerSnake.isAlive && playerSnake.body.length > 0) {
        cameraX = playerSnake.body[0].x - VIEW_SIZE.width / 2;
        cameraY = playerSnake.body[0].y - VIEW_SIZE.height / 2;
    }

    // 2. Clear canvas (Draw background)
    ctx.fillStyle = '#161b22';
    ctx.fillRect(0, 0, VIEW_SIZE.width, VIEW_SIZE.height);

    // Draw World Boundary 
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 10;
    ctx.strokeRect(-cameraX, -cameraY, WORLD_SIZE, WORLD_SIZE);
    ctx.lineWidth = 1; 

    // 3. Draw Food
    ctx.fillStyle = '#fef3c7'; 
    for (const f of food) {
        const drawX = f.x - cameraX;
        const drawY = f.y - cameraY;

        if (drawX > -FOOD_RADIUS && drawX < VIEW_SIZE.width + FOOD_RADIUS &&
            drawY > -FOOD_RADIUS && drawY < VIEW_SIZE.height + FOOD_RADIUS) {
            ctx.beginPath();
            ctx.arc(drawX, drawY, FOOD_RADIUS, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // 4. Draw Snakes
    for (const snake of snakes) {
        if (!snake.isAlive) continue;

        ctx.fillStyle = snake.color;
        for (let i = 0; i < snake.body.length; i++) {
            const segment = snake.body[i];
            const drawX = segment.x - cameraX;
            const drawY = segment.y - cameraY;

            if (drawX > -SNAKE_RADIUS && drawX < VIEW_SIZE.width + SNAKE_RADIUS &&
                drawY > -SNAKE_RADIUS && drawY < VIEW_SIZE.height + SNAKE_RADIUS) {
                ctx.beginPath();
                ctx.arc(drawX, drawY, SNAKE_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw name above the head
        if (snake.body.length > 0) {
            const head = snake.body[0];
            const drawX = head.x - cameraX;
            const drawY = head.y - cameraY;
            ctx.fillStyle = snake.isPlayer ? '#3b82f6' : '#ffffff';
            ctx.font = 'bold 14px Inter';
            ctx.textAlign = 'center';
            ctx.fillText(snake.name, drawX, drawY - SNAKE_RADIUS - 5);
        }
    }

    // 5. Draw Leader Indicator
    // Note: leaderSnake is still the absolute #1 snake for the indicator
    if (leaderSnake && leaderSnake.isAlive && leaderSnake.id !== playerSnake.id && playerSnake.body.length > 0 && leaderSnake.body.length > 0) {
        const leaderHead = leaderSnake.body[0];
        const playerHead = playerSnake.body[0];
        
        // Coordinates of the leader's head on the screen (if visible)
        const drawX = leaderHead.x - cameraX;
        const drawY = leaderHead.y - cameraY;
        
        // Check if leader is on-screen (with a small margin)
        const margin = 50;
        const isVisible = (drawX > -margin && drawX < VIEW_SIZE.width + margin &&
                           drawY > -margin && drawY < VIEW_SIZE.height + margin);

        ctx.save();

        if (isVisible) {
            // --- ON-SCREEN STAR INDICATOR ---
            ctx.translate(drawX, drawY);

            const flashOpacity = Math.abs(Math.sin(performance.now() / 300));

            // Outer ring (pulsing)
            ctx.beginPath();
            ctx.strokeStyle = `rgba(255, 255, 0, ${0.5 + flashOpacity * 0.5})`;
            ctx.lineWidth = 3;
            ctx.arc(0, 0, SNAKE_RADIUS + 8, 0, Math.PI * 2);
            ctx.stroke();

            // Inner pointer/star
            ctx.fillStyle = '#ffeb3b'; 
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚òÖ', 0, 0); 
            
        } else {
            // --- OFF-SCREEN ARROW INDICATOR ---
            
            const dx = leaderHead.x - playerHead.x;
            const dy = leaderHead.y - playerHead.y;
            const arrowAngle = Math.atan2(dy, dx);
            
            const center_x = VIEW_SIZE.width / 2;
            const center_y = VIEW_SIZE.height / 2;

            // Calculate the radius for the arrow to sit near the edge
            const maxRadius = Math.min(center_x, center_y);
            const arrowRadius = maxRadius - ARROW_MARGIN;

            const arrowX = center_x + Math.cos(arrowAngle) * arrowRadius;
            const arrowY = center_y + Math.sin(arrowAngle) * arrowRadius;

            // 1. Translate to the arrow position
            ctx.translate(arrowX, arrowY);
            // 2. Rotate to align with the target direction
            ctx.rotate(arrowAngle);
            
            ctx.fillStyle = '#ffeb3b';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            
            // Draw a triangle shape pointing right (along the angle 0)
            ctx.beginPath();
            ctx.moveTo(ARROW_SIZE, 0); // Tip
            ctx.lineTo(-ARROW_SIZE / 2, -ARROW_SIZE); // Bottom left
            ctx.lineTo(-ARROW_SIZE / 2, ARROW_SIZE); // Bottom right
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        ctx.restore();
    }
}

// --- AI Logic (Updated with Predator Kill Strategy and Give-Up Logic) ---
function runAISnake(snake) {
    if (!snake.isAlive) return;

    const head = snake.body[0];
    let targetAngle = snake.angle;
    let avoidanceRequired = false; 
    let obstaclePos = null; 
    
    // Calculate the point the snake will reach soon, based on the LOOK_AHEAD_DISTANCE
    const lookAheadX = head.x + Math.cos(snake.angle) * LOOK_AHEAD_DISTANCE;
    const lookAheadY = head.y + Math.sin(snake.angle) * LOOK_AHEAD_DISTANCE;


    // --- 0. CRITICAL BOUNDARY AVOIDANCE (Highest Priority) ---
    const halfWorld = WORLD_SIZE / 2;
    if (head.x < EDGE_AVOIDANCE_MARGIN || head.x > WORLD_SIZE - EDGE_AVOIDANCE_MARGIN || 
        head.y < EDGE_AVOIDANCE_MARGIN || head.y > WORLD_SIZE - EDGE_AVOIDANCE_MARGIN) {
        
        const dxCenter = halfWorld - head.x;
        const dyCenter = halfWorld - head.y;
        targetAngle = Math.atan2(dyCenter, dxCenter);
        targetAngle += (Math.random() - 0.5) * 0.2; 
        
        snake.targetAngle = targetAngle;
        snake.avoidanceDirection = 0; 
        snake.tempWanderTimer = 0; // Reset timer on boundary avoidance
        return; 
    }

    // --- 1. COLLISION CHECK (Check Look-Ahead Point against ALL snake bodies) ---
    // This is CRITICAL: If the AI's projected path hits a body, hunting is cancelled/avoidance is triggered.
    for (const s of snakes) {
        if (!s.isAlive) continue; 
        
        // Check against own body (skipping the first few segments)
        const startSegment = (s.id === snake.id) ? 4 : 0;
        
        for (let i = startSegment; i < s.body.length; i++) { 
            const segment = s.body[i];
            
            const dx = lookAheadX - segment.x;
            const dy = lookAheadY - segment.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < COLLISION_DANGER_RADIUS) {
                avoidanceRequired = true;
                obstaclePos = segment; 
                break;
            }
        }
        if (avoidanceRequired) break;
    }


    // --- 2. ACTION ---
    if (avoidanceRequired && obstaclePos) {
        // --- AVOIDANCE MANEUVER (PRIORITIZED OVER HUNTING, TRIGGERING 'GIVE UP') ---
        
        // If we are forced to avoid, we are "giving up" the current hunt/food target temporarily
        // to prevent circling into danger.
        snake.tempWanderTimer = GIVE_UP_TIME_FRAMES; 
        
        // If not already avoiding, pick a random direction (+1 or -1)
        if (snake.avoidanceDirection === 0) {
            snake.avoidanceDirection = Math.random() < 0.5 ? 1 : -1;
        }

        // Steer away from the current obstacle position
        const dx = obstaclePos.x - head.x;
        const dy = obstaclePos.y - head.y;
        const angleToObstacle = Math.atan2(dy, dx);

        // Turn perpendicular to the obstacle angle, adjusted by the avoidance direction
        targetAngle = angleToObstacle + snake.avoidanceDirection * Math.PI * 0.5; 
        
        // Add a small randomized component
        targetAngle += (Math.random() - 0.5) * 0.4; 
        
    } else {
        // --- PREDATOR MODE / FOOD SEEKING ---
        snake.avoidanceDirection = 0; // Path is clear
        
        // Decrement the forced wandering timer
        if (snake.tempWanderTimer > 0) {
            snake.tempWanderTimer--;
        }

        let hunting = false;
        
        // Only hunt if the temporary wander timer has expired
        if (snake.tempWanderTimer === 0) {
            // New logic: Get top 3 snakes (excluding self)
            const topSnakes = snakes
                .filter(s => s.isAlive && s.id !== snake.id)
                .sort((a, b) => b.score - a.score)
                .slice(0, 3); // Grab top 3 available targets
                
            if (topSnakes.length > 0) {
                // Randomly select one of the top available targets
                const huntTarget = topSnakes[Math.floor(Math.random() * topSnakes.length)];
                
                const huntTargetHead = huntTarget.body[0];
                
                const dxLeader = huntTargetHead.x - head.x;
                const dyLeader = huntTargetHead.y - head.y;
                const distSqLeader = dxLeader * dxLeader + dyLeader * dyLeader;
    
                if (distSqLeader < HUNT_RADIUS_SQ) {
                    // We are hunting!
                    
                    // --- PREDATOR KILL LOGIC ---
                    // Aim for a predicted intercept point ahead of the target
                    const leaderAngle = huntTarget.angle;
    
                    const predictedX = huntTargetHead.x + Math.cos(leaderAngle) * PREDATOR_PREDICTION_DISTANCE;
                    const predictedY = huntTargetHead.y + Math.sin(leaderAngle) * PREDATOR_PREDICTION_DISTANCE;
    
                    const dxPredicted = predictedX - head.x;
                    const dyPredicted = predictedY - head.y;
                    
                    targetAngle = Math.atan2(dyPredicted, dxPredicted);
                    targetAngle += (Math.random() - 0.5) * 0.05; // Small jitter
                    
                    hunting = true;
                }
            }
        } 

        if (!hunting) {
            // --- HIGH-PRIORITY FOOD SEEKING / WANDERING ---
            // If hunting is skipped (due to timer or distance), focus on food/wandering.
            
            let targetPosition = null;
            let minDistanceSq = Infinity;
            let nearestFood = null;

            // Find the nearest food item within the search radius
            for (const f of food) {
                const dx = f.x - head.x;
                const dy = f.y - head.y;
                const distSq = dx * dx + dy * dy;

                if (distSq < minDistanceSq && distSq < FOOD_SEARCH_RADIUS_SQ) {
                    minDistanceSq = distSq;
                    nearestFood = f;
                }
            }
            
            if (nearestFood) {
                const dx = nearestFood.x - head.x;
                const dy = nearestFood.y - head.y;
                targetAngle = Math.atan2(dy, dx);
                
                // Calculate angular difference and reject food too far behind
                let angleDiff = targetAngle - snake.angle;
                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                if (Math.abs(angleDiff) > MAX_FOOD_ANGLE_DIFF) {
                    nearestFood = null; 
                } else {
                    targetPosition = nearestFood;
                }
            }

            // Execute Seeking/Wandering
            if (nearestFood) {
                // targetAngle is already calculated to be toward the accepted food
                targetAngle += (Math.random() - 0.5) * 0.05; // Small jitter while eating
            } else {
                // No viable food found or hunting is temporarily disabled, wander towards the center
                const dxCenter = halfWorld - head.x;
                const dyCenter = halfWorld - head.y;
                targetAngle = Math.atan2(dyCenter, dxCenter);
                targetAngle += (Math.random() - 0.5) * 0.1;
            }
        }
    }

    // Set the calculated target angle
    snake.targetAngle = targetAngle;
}

// Function to find the top scoring snake
function getLeaderSnake() {
    return snakes
        .filter(s => s.isAlive)
        .sort((a, b) => b.score - a.score)[0] || playerSnake; // Default to player if no one else is alive
}

// --- Player Respawn Logic (unchanged) ---
function respawnPlayer() {
    if (playerSnake.isRespawning) return; 

    playerSnake.isRespawning = true;
    playerSnake.isAlive = false; 

    if (playerSnake.body.length > 0) {
        // Drop food upon death
        playerSnake.body.forEach(segment => food.push(new Food(segment.x, segment.y)));
        playerSnake.body = []; 
    }

    const statusDiv = document.getElementById('status-message');
    document.getElementById('status-text').textContent = `You crashed! Respawning...`;
    statusDiv.classList.remove('hidden');

    setTimeout(() => {
        playerSnake.reset(); 
        playerSnake.isRespawning = false;
        statusDiv.classList.add('hidden');
    }, 1000); 
}

// --- Collision and Update Logic (unchanged logic, only refactored) ---
function update() {
    // Find the leader at the start of the update cycle for AI and drawing
    leaderSnake = getLeaderSnake(); 

    snakes.forEach(snake => {
        if (!snake.isAlive) {
            if (snake.isPlayer && !snake.isRespawning) {
                respawnPlayer();
            } else if (!snake.isPlayer && !snake.isDeadAndAwaitingReset) {
                snake.isDeadAndAwaitingReset = true;
                snake.body.forEach(segment => food.push(new Food(segment.x, segment.y)));
                setTimeout(() => {
                    snake.reset();
                    snake.isDeadAndAwaitingReset = false;
                }, 5000);
            }
            return; 
        }
        
        // 1. Run AI logic for non-player snakes
        if (!snake.isPlayer) {
            runAISnake(snake);
        }

        // 2. Move
        snake.move();
        const head = snake.body[0];

        // 3. World Boundary Check
        const isOutOfBounds = head.x < 0 || head.x > WORLD_SIZE ||
                              head.y < 0 || head.y > WORLD_SIZE;

        if (isOutOfBounds) {
            snake.isAlive = false;
            return; 
        }

        // 4. Collision with other snakes' bodies
        let hitSnake = false;
        for (const s of snakes) {
            if (s.id === snake.id || !s.isAlive) continue; 

            const otherHead = s.body[0];

            // 4a. Check for Head-to-Head Collision (Mutual Death)
            const dxHead = head.x - otherHead.x;
            const dyHead = head.y - otherHead.y;
            const distanceSqHead = dxHead * dxHead + dyHead * dyHead;

            if (distanceSqHead < (SNAKE_RADIUS * 2) ** 2) {
                snake.isAlive = false; 
                s.isAlive = false;     
                hitSnake = true;
                break;
            }

            // 4b. Check for Head-to-Body Collision (Current snake dies)
            // Note: We check from segment 1, as colliding with segment 0 (the head) is handled above.
            for (let i = 1; i < s.body.length; i++) { 
                const segment = s.body[i];
                const dx = head.x - segment.x;
                const dy = head.y - segment.y;
                const distanceSq = dx * dx + dy * dy;

                if (distanceSq < (SNAKE_RADIUS * 2) ** 2) {
                    snake.isAlive = false; 
                    hitSnake = true;
                    
                    if (s.isAlive) { 
                        const killerName = s.name;
                        const victimName = snake.name;
                        
                        killLog.unshift({ killer: killerName, victim: victimName });
                        
                        if (killLog.length > MAX_KILL_LOG) {
                            killLog.pop();
                        }
                        updateKillLog(); 

                        s.isKiller = true;
                        setTimeout(() => { 
                            if(s) s.isKiller = false;
                            updateLeaderboard(); 
                        }, 1000);
                    }

                    break;
                }
            }
            if (hitSnake) break;
        }

        if (hitSnake) {
            return; 
        }

        // 5. Food Eating
        for (let i = food.length - 1; i >= 0; i--) {
            const f = food[i];
            const dx = head.x - f.x;
            const dy = head.y - f.y;
            const distanceSq = dx * dx + dy * dy;

            if (distanceSq < (SNAKE_RADIUS + FOOD_RADIUS) ** 2) {
                food.splice(i, 1);
                snake.grow();
            }
        }

        // 6. Update score display
        if (snake.isPlayer) {
            document.getElementById('player-score').textContent = snake.score;
        }
    });

    spawnFood();
    updateLeaderboard();
}


// --- Leaderboard (unchanged) ---
function updateLeaderboard() {
    const leaderboardDiv = document.getElementById('leaderboard');
    const sortedSnakes = snakes
        .filter(s => s.isAlive)
        .sort((a, b) => b.score - a.score)
        .slice(0, 6);

    leaderboardDiv.innerHTML = sortedSnakes.map((snake, index) => `
        <div class="leaderboard-item flex justify-between p-1 rounded-md text-gray-200 
            ${snake.isPlayer ? 'player-snake' : 'hover:bg-gray-800'}
            ${snake.isKiller ? 'killer-flash' : ''}" style="color: ${snake.isPlayer ? '#3b82f6' : snake.color}">
            <span class="font-medium">#${index + 1}</span>
            <span class="font-semibold truncate text-right">${snake.name}</span>
            <span class="font-bold">${snake.score}</span>
        </div>
    `).join('');
}

// --- Kill Log Display (unchanged) ---
function updateKillLog() {
    const logDiv = document.getElementById('kill-log');
    
    logDiv.innerHTML = killLog.map(logEntry => {
        const killerColor = logEntry.killer === 'You' ? 'text-green-400' : 'text-yellow-400';
        const victimColor = logEntry.victim === 'You' ? 'text-red-400' : 'text-gray-400';
        
        return `<p class="text-[10px] text-gray-300 whitespace-nowrap overflow-hidden text-ellipsis">
            <span class="${killerColor} font-bold">${logEntry.killer}</span> killed 
            <span class="${victimColor} font-bold">${logEntry.victim}</span>
        </p>`;
    }).join('');
}


// --- Game Loop and Control (unchanged) ---
const targetFPS = 60;
const frameDuration = 1000 / targetFPS;

function gameLoop(timestamp) {
    if (!gameRunning) return;

    let elapsed = timestamp - lastTime;
    if (elapsed > frameDuration) {
        update();
        lastTime = timestamp - (elapsed % frameDuration);
    }
    
    draw(); 

    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- Input Handling (Mouse/Touch Steering, unchanged) ---
canvas.addEventListener('mousemove', handleInput, false);
canvas.addEventListener('touchmove', (e) => {
    e.preventDefault(); 
    handleInput(e.touches[0]);
}, false);

function handleInput(event) {
    if (!playerSnake || !gameRunning || !playerSnake.isAlive) return; 

    let clientX, clientY;
    if (event.touches) {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
    } else {
        clientX = event.clientX;
        clientY = event.clientY;
    }

    const rect = canvas.getBoundingClientRect();
    const viewX = clientX - rect.left;
    const viewY = clientY - rect.top;

    const dx = viewX - VIEW_SIZE.width / 2;
    const dy = viewY - VIEW_SIZE.height / 2;

    const targetAngle = Math.atan2(dy, dx);

    playerSnake.setTargetAngle(targetAngle);
}

// Start the game on load
window.onload = initGame;

</script>

</body>
</html>
